<!doctype html><html lang="es"><head>
<meta charset="utf-8"><meta name="viewport" content="width=device-width,initial-scale=1">
<title>P2 — Movimiento o gesto que piensas ahora</title>
<link rel="stylesheet" href="style.css">
<script defer src="state.js"></script>
<style>
  #cam.mirror { transform: scaleX(-1); } /* sólo vista previa */
</style>
</head><body>
<main class="wrap">
  <div class="card">
    <h1>2) ¿Qué movimiento o gesto piensas ahora?</h1>
    <p>Graba un breve vídeo (3–5 s). Usa la frontal (selfie, espejo) o cambia a la trasera.</p>

    <div class="grid2">
      <div>
        <video id="cam" playsinline autoplay muted style="width:100%;border-radius:12px;background:#000"></video>
        <div class="actions" style="margin-top:10px;gap:8px;flex-wrap:wrap">
          <button class="btn" id="toggleFacing">↔︎ Cambiar cámara</button>
          <button class="btn" id="rec">● Grabar</button>
          <button class="btn" id="stop" disabled>■ Detener</button>
        </div>
        <p class="hint" id="hint">Pulsa “Grabar”, vuelve a “Detener” o espera el autostop a los 5 s.</p>
      </div>

      <div>
        <label>Previsualización</label>
        <div class="preview" id="prev">Aún sin vídeo</div>
      </div>
    </div>

    <div class="actions">
      <a class="btn" href="q1.html">← Volver</a>
      <button class="btn primary" id="next" disabled>Siguiente →</button>
    </div>
  </div>
</main>

<script>
const videoEl   = document.getElementById('cam');
const btnFacing = document.getElementById('toggleFacing');
const btnRec    = document.getElementById('rec');
const btnStop   = document.getElementById('stop');
const btnNext   = document.getElementById('next');
const prev      = document.getElementById('prev');
const hint      = document.getElementById('hint');

let facingMode = 'user';        // 'user' (frontal) | 'environment' (trasera)
let mirrorOn   = true;          // sólo en frontal
let camStream  = null;          // stream de la cámara
let recorder   = null;          // MediaRecorder en uso
let chunks     = [];            // datos grabados
let rafId      = null;          // id del requestAnimationFrame del pipeline espejo
let pipedStream= null;          // stream del canvas (cuando espejo)
let videoDataUrl = null;

// inicia/renueva la cámara
async function startCamera(){
  try{
    stopAll();
    camStream = await navigator.mediaDevices.getUserMedia({
      video: { facingMode: { ideal: facingMode }, width:{ideal:1280}, height:{ideal:720} },
      audio: true
    });
    videoEl.srcObject = camStream;

    mirrorOn = (facingMode === 'user');
    videoEl.classList.toggle('mirror', mirrorOn);
  }catch(e){
    alert('No se pudo acceder a la cámara. Revisa permisos/permisos del navegador.');
    console.error(e);
  }
}
startCamera();

// alternar frontal/trasera
btnFacing.addEventListener('click', async ()=>{
  facingMode = (facingMode === 'user') ? 'environment' : 'user';
  await startCamera();
});

// crea un pipeline espejo con canvas y devuelve {stream, stopFn}
function buildMirroredStream(sourceVideo, sourceStream){
  const vw = sourceVideo.videoWidth  || 640;
  const vh = sourceVideo.videoHeight || 360;
  const canvas = document.createElement('canvas');
  canvas.width = vw; canvas.height = vh;
  const ctx = canvas.getContext('2d');

  function draw(){
    ctx.save();
    ctx.translate(canvas.width, 0);
    ctx.scale(-1, 1);
    ctx.drawImage(sourceVideo, 0, 0, canvas.width, canvas.height);
    ctx.restore();
    rafId = requestAnimationFrame(draw);
  }
  draw();

  const stream = canvas.captureStream(30); // vídeo del canvas
  // añade la pista de audio original si existe
  try{
    const audioTrack = sourceStream.getAudioTracks()[0];
    if (audioTrack) stream.addTrack(audioTrack);
  }catch(_){}
  const stopFn = ()=>{ if(rafId) cancelAnimationFrame(rafId); };

  return {stream, stopFn};
}

// comenzar grabación
btnRec.addEventListener('click', async ()=>{
  if(!camStream){ alert('No hay cámara'); return; }
  chunks = [];
  btnRec.disabled = true; btnStop.disabled = true; // se habilita cuando hay stream listo

  // Asegura que el <video> está listo para conocer dimensiones
  if (!videoEl.videoWidth){ await new Promise(r=> setTimeout(r, 200)); }

  let streamToRecord = camStream;
  let stopMirror = null;

  if (facingMode === 'user'){ // frontal → espejo real en el archivo
    const built = buildMirroredStream(videoEl, camStream);
    streamToRecord = built.stream;
    stopMirror = built.stopFn;
  }

  recorder = new MediaRecorder(streamToRecord, { mimeType: 'video/webm' });
  recorder.ondataavailable = e=> chunks.push(e.data);
  recorder.onstop = async ()=>{
    if (stopMirror) stopMirror();
    const blob = new Blob(chunks, { type:'video/webm' });
    videoDataUrl = await blobToDataURL(blob);

    const v = document.createElement('video');
    v.controls = true; v.src = videoDataUrl;
    v.style.width='100%'; v.style.borderRadius='12px';
    prev.innerHTML = ''; prev.appendChild(v);
    btnNext.disabled = false;
  };

  recorder.start();
  hint.textContent = 'Grabando…';
  btnStop.disabled = false;

  // autostop a los 5s
  setTimeout(()=>{
    if (recorder && recorder.state === 'recording'){ recorder.stop(); hint.textContent='Grabación finalizada'; }
    btnRec.disabled = false; btnStop.disabled = true;
  }, 5000);
});

btnStop.addEventListener('click', ()=>{
  if (recorder && recorder.state === 'recording'){
    recorder.stop(); hint.textContent='Grabación finalizada';
  }
  btnRec.disabled = false; btnStop.disabled = true;
});

// guardar y pasar
btnNext.addEventListener('click', ()=>{
  if (typeof writeTmp === 'function') {
    writeTmp({ videoClip: videoDataUrl || null });
  } else {
    sessionStorage.setItem('videoClip', videoDataUrl || '');
  }
  stopAll();
  location.href='q3.html';
});

function stopAll(){
  if (recorder && recorder.state === 'recording'){ recorder.stop(); }
  if (camStream){ camStream.getTracks().forEach(t=>t.stop()); camStream=null; }
  if (rafId){ cancelAnimationFrame(rafId); rafId=null; }
}

window.addEventListener('pagehide', stopAll);

// util (misma que usas en state.js para audio/fotos)
function blobToDataURL(blob){
  return new Promise(res=>{ const r=new FileReader(); r.onload=()=>res(r.result); r.readAsDataURL(blob); });
}
</script>
</body></html>
